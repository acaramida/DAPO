import cotls;
include "file_io";
pragma mode = randomized;

int t1 = System.getCPUTime();
string fname = "anna.col";
string directory = "../tests/";
int[,] mat = readDimacsGraph(directory + fname);
//showMat(mat);

int n = mat.getSize(0);
range Vertices = 1..n;
range D = 0..1;

Solver<LS> ls();
   ConstraintSystem<LS> S(ls);
   /**
      Array of all vertices with values 0 or 1
      0 means it doesn't belong to the dominating set
      1 means it belongs
   */
   var{int} s[i in Vertices] (ls, D) := 0;

   //Seed, start with a random vertex set to 1
   select(v in Vertices)
         s[v] := 1;

   /**
      For every vertex that is covered it needs to be in the set
      or have a neighbour that is, this means for all vertices of s
      the sum of the vertex with the sum of all its neighbors has to be 1 or bigger.
   */
   forall (i in Vertices) {
      S.post(1 <= s[i] + sum(j in Vertices:  mat[i, j] > 0) (s[j]) );
   }
   
   // Function for the size of the set
   FunctionExpr<LS> F( sum (v in Vertices) s[v] );

   /** 
      Otimisation function
      gives more importance to covering all vertices than minimizing the set (ratio 11:10)
   */
   Function<LS> G = 11*S + 10*F;

   // Pointer for the violations
   var{int} violations = S.violations();
    
ls.close();

int maxit = 2*n;
int it = 0;
int change = 0;
int max_change = n;
int best = violations; int best_s = n; int best_it = it;
int tbl = 4; int tblMin = 2; int tblMax = 10; int tabu[Vertices] = 0;
Solution solution(ls);
int nonImprovingSteps = 0; int maxNonImproving = 100; int restartFreq = 1500;

while(it < maxit && change < max_change) {
   int old = violations;
   /**
      choose the vertex that leads to the smallest number of violations (the minimal
      delta), if we change s[vertex] to 0 when it was 1 and vice versa.
      only non-tabu assignments are considered.
   */
   selectMin(i in Vertices, delta = G.getAssignDelta(s[i], 1-s[i]): tabu[i] <= it || delta + violations < best) (delta){
      //update tabu and s[i] 
      tabu[i] = it + tbl;
      s[i] := 1-s[i];

      // make tabu length change according to violations
      if (violations < old && tbl > tblMin)
         tbl--;
      if (violations >= old && tbl < tblMax)
         tbl++;

      /*cout << " change var " << i << " to "<< s[i] <<"; delta = "<< delta << endl;  
      cout << "-- iteration = " << it << "; violations = " << violations <<"; set size = "<< F.evaluation() << endl;*/
   
   }
   /**
      If the new assignment improves the best solution found, then the new assignment is stored into
      the Solution object solution, variable best is updated to reflect the new best number of violations,
      and the number of non-improving iterations is reset to 0
   */
   if (violations < best || (violations == 0 && F.evaluation() < best_s)){
      best = violations;
      best_s = F.evaluation();
      best_it = it;
      solution = new Solution(ls);
      nonImprovingSteps = 0;
      if(violations == 0)
         cout << "best so far of " << best << " with size " << best_s <<" at iteration " << best_it << endl;endl;
   }
   /** 
       Check if the maximum limit for non-improving iterations has been reached,
       currently best solution, stored in variable solution is restored and the
       number of non-improving iterations is reset to 0
   */
   else if (nonImprovingSteps == maxNonImproving) {
      solution.restore();
      nonImprovingSteps = 0;
   }
   /**
      Counter for non-improving is increased
   */
   else {
      nonImprovingSteps++;
      change++; 
   }
   /** 
      Check if restartFreq is reached and no solution found
      if true restart with a new seed
   */
   if (it !=0 && (it % restartFreq == 0) && (best > 0) ) {
      // change a randomm vertex
      with delay(ls)
         forall (i in Vertices)
            s[i] := 0;
      select(v in Vertices)
         s[v] := 1-s[v];
      best = S.violations();
      best_s = F.evaluation();
      solution = new Solution(ls);
   }

   it++;
}

int t2 = System.getCPUTime();

cout << " ----------- " << endl;
cout << " best iteration : "<< best_it << endl;
cout << " best violations : "<< best << endl;
cout << " best mds : "<< best_s << endl;
cout << "cpu time (ms) = " << t2-t1 <<endl;
