import cotls;
include "file_io";
pragma mode = randomized;

int t1 = System.getCPUTime();
string fname = "gplus_2000.col";
string directory = "../tests/";
int[,] mat = readDimacsGraph(directory + fname);
//showMat(mat);

int n = mat.getSize(0);
range Vertices = 1..n;
range D = 0..1;

Solver<LS> ls();
   ConstraintSystem<LS> S(ls);
   /**
      Array of all vertices with values 0 or 1
      0 means it doesn't belong to the dominating set
      1 means it belongs
   */
   var{int} s[i in Vertices] (ls, D) := 0;

   //start with a random vertex set to 1
   select(v in Vertices)
         s[v] := 1;

   /**
      For every vertex that is covered it needs to be in the set
      or have a neighbour that is
   */
   forall (i in Vertices) {
      S.post(1 <= s[i] + sum(j in Vertices:  mat[i, j] > 0) (s[j]) );
   }

   FunctionExpr<LS> F( sum (v in Vertices) s[v] );

   Function<LS> G = 11*S + 10*F;

   var{int} violations = S.violations();
    
ls.close();

int maxit = 2*n;
int it = 0;
int change = 0;
int max_change = n/2;
int best = violations; int best_s = n; int best_it = it;
int tbl = 4; int tblMin = 2; int tblMax = 10; int tabu[Vertices] = 0;
Solution solution(ls);
int nonImprovingSteps = 0; int maxNonImproving = 100; int restartFreq = 1000;

cout << "-- iteration start; violations = " << violations <<"; set size = "<< F.evaluation() << endl;
while(it < maxit && change < max_change) {
   int old = violations;
   /**
      choose the vertex that leads to the smallest number of violations (the minimal
      delta), if we change s[vertex] to 0 when it was 1 and vice versa.
      only non-tabu assignments are considered.
   */
   selectMin(i in Vertices, delta = G.getAssignDelta(s[i], 1-s[i]): tabu[i] <= it || delta + violations < best) (delta){
      //update tabu and s[i] 
      tabu[i] = it + tbl;
      s[i] := 1-s[i];

      // make tabu length change according to violations
      if (violations < old && tbl > tblMin)
         tbl--;
      if (violations >= old && tbl < tblMax)
         tbl++;

      cout << " change var " << i << " to "<< s[i] <<"; delta = "<< delta << endl;  
      cout << "-- iteration = " << it << "; violations = " << violations <<"; set size = "<< F.evaluation() << endl;
   
   }
   /**
      If the new assignment improves the best solution found, then the new assignment is stored into
      the Solution object solution, variable best is updated to reflect the new best number of violations,
      and the number of non-improving iterations is reset to 0
   */
   if (violations < best || (violations == 0 && F.evaluation() < best_s)){
      best = violations;
      best_s = F.evaluation();
      best_it = it;
      solution = new Solution(ls);
      nonImprovingSteps = 0;
   } 
   /** 
       Check if the maximum limit for non-improving iterations has been reached,
       currently best solution, stored in variable solution is restored and the
       number of non-improving iterations is reset to 0
   */
   else if (nonImprovingSteps == maxNonImproving) {
      solution.restore();
      nonImprovingSteps = 0;
   }
   /**
      Counter for non-improving is increased
   */
   else
      nonImprovingSteps++;
   /** 
      Check if restartFreq is reached and no solution found
      change a random vertex to inverse (0 to 1, 1 to 0)
   */
   if (it !=0 && (it % restartFreq == 0) && (best > 0) ) {
      // change a randomm vertex
      select(v in Vertices)
         s[v] := 1-s[v];
      best = S.violations();
      best_s = F.evaluation();
      solution = new Solution(ls);
   } else
      change= change + 1;

   it++;
}

int t2 = System.getCPUTime();

cout << " ----------- " << endl;
cout << " best iteration : "<< best_it << endl;
cout << " best violations : "<< best << endl;
cout << " best mds : "<< best_s << endl;
cout << "cpu time (ms) = " << t2-t1 <<endl;
