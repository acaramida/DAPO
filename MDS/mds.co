import cotls;
include "file_io";
pragma mode = randomized;

int t1 = System.getCPUTime();
string fname = "gplus_10000.col";
string directory = "../tests/";
int[,] mat = readDimacsGraph(directory + fname);
//showMat(mat);

int n = mat.getSize(0);
range Vertices = 1..n;
range D = 0..1;

UniformDistribution dist(Vertices);

Solver<LS> ls();

   ConstraintSystem<LS> S(ls);
   /**
      Array of all vertices with values 0 or 1
      0 means it doesn't belong to the dominating set
      1 means it belongs
   */
   var{int} s[i in Vertices] (ls, D) := 0;

   //start with a random vertex set to 1
   s[dist.get()] := 1;

   /**
      For every vertex that is covered it needs to be in the set
      or have a neighbour that is, this means for all vertices of s
      the sum of the vertex with the sum of all its neighbors has to be 1 or bigger.
   */
   forall (i in Vertices) {
      S.post(1 <= s[i] + sum(j in Vertices:  mat[i, j] > 0) (s[j]) );
   }

   FunctionExpr<LS> F( sum (v in Vertices) s[v] );

   Function<LS> G = 11*S + 10*F;

   var{int} violations = S.violations();
    
ls.close();

int maxit = n;
int it = 0;
int best = violations; int best_s = n; int best_it = it;

cout << "-- iteration start; violations = " << violations <<"; set size = "<< F.evaluation() << endl;
while(it < maxit) {
   selectMin(i in Vertices) (G.getAssignDelta(s[i], 1-s[i])){
      s[i] := 1-s[i];

     cout << " change var " << i << " to "<< s[i] << endl;  
     cout << "-- iteration = " << it << "; violations = " << violations <<"; set size = "<< F.evaluation() << endl;
      
   }

   if (violations < best || (violations == 0 && F.evaluation() < best_s)){
      best = violations;
      best_s = F.evaluation();
      best_it = it;
   }
 
   it++;
}
int t2 = System.getCPUTime();

cout << " ----------- " << endl;
cout << " best iteration : "<< best_it << endl;
cout << " best violations : "<< best << endl;
cout << " best mds : "<< best_s << endl;
cout << "cpu time (ms) = " << t2-t1 <<endl;