import cotls;

function string extend_name(string fname){
  string [] dirs = System.getArgs();
  string directory = dirs[2].suffix(2);
  string ename = directory + "/" + fname;
  return ename;
}

// READ functions

// read optimum dominating set
function int getOptimum(string fName) { // mds
   string optName = extend_name(fName);
   ifstream ipt(optName);
   string [] dims;

   do{
       dims = ipt.getLine().split(" ");
   }while(dims[0] != "p");
   
   return dims[4].toInt();
}

function int [,]readDimacsGraph(string fName) { // mds 
   string optName = extend_name(fName);
   ifstream ipt(optName);
   string [] dims;

   do{
       dims = ipt.getLine().split(" ");
   }while(dims[0] != "p");
   
   int m = dims[2].toInt();
   int n = dims[3].toInt();
   int mat[1..m, 1..m] = 0;

   forall(i in 1..n){
      string [] line = ipt.getLine().split(" ");
      int i = line[1].toInt();
      int j = line[2].toInt();
      mat[i,j] = 1;
      mat[j,i] = 1;
     }

   return mat;
}

function int [,] readEdgeGraph(string fName) { // bgp, mbo, mcp, 
   string optName = extend_name(fName);
   ifstream ipt(optName); 
   string [] dims = ipt.getLine().split(" ");
   int m = dims[0].toInt();
   int n = dims[1].toInt();
   int mat[1..m, 1..m] = 0;
   forall(i in 1..n){
      string [] line = ipt.getLine().split(" ");
      int i = line[0].toInt();
      int j = line[1].toInt();
      mat[i,j] = 1;
      mat[j,i] = 1;
   }
   return mat;
}

function bool [,] readGraph(string fName){
   string iptName = extend_name(fName);
   ifstream file(iptName);
   int nn = file.getInt();
   int ne = file.getInt();
   range Nodes = 1..nn;

   bool e[Nodes,Nodes] = false;
   forall(i in 1..ne){
      string dummy = file.getString();
      int i = file.getInt(); int j = file.getInt();
      e[i,j] = true; e[j,i] = true;
   }
   return e;
}


function void writeGraph(bool [,] g){
   range R = g.getRange(0); 
   forall(i in R){
      cout << endl;
      forall(j in R) cout << " " << g[i,j]*1;
   }
}

function int [,] readEdgeWeightedGraph(string fName) {
   string iptName = extend_name(fName);
   ifstream ipt(iptName); 
   string [] dims = ipt.getLine().split(" ");
   int m = dims[0].toInt();
   int n = dims[1].toInt();
   int mat[1..m, 1..m] = 0;
   forall(i in 1..n){
      string [] line = ipt.getLine().split(" ");
      int i = line[0].toInt();
      int j = line[1].toInt();
      int k = line[2].toInt();
      mat[i,j] = k;
      mat[j,i] = k;
   }
   return mat;
}


function int [,] readMatGraph_bad(string fName) {  // gcp, tsp
   string optName = extend_name(fName);
   ifstream ipt(optName); 
   string [] dims = ipt.getLine().split(" ");
   int m = dims[0].toInt();
   int n = dims[1].toInt();
   int mat[1..m, 1..n];
   forall(i in 1..m){
      string [] line = ipt.getLine().split(" ");
      forall(j in 1..n) 
         mat[i,j] = line[j].toInt();
   }
   return mat;
}
function int [,] readMatGraph(string fName) {  // gcp, tsp
   string optName = extend_name(fName);
   ifstream ipt(optName); 
   string [] dims = ipt.getLine().split(" ");
   int m = dims[0].toInt();
   int n = dims[1].toInt();
   int mat[1..m, 1..n];
   forall(i in 1..m){
      string [] line = ipt.getLine().split(" ");
      int k = 0;
      forall(j in 1..n)  {
         while(line[k] == "") k++; // Ignore empty strings caused by multiple whitespaces
         mat[i,j] = line[k].toInt();
         k++;
      }
   }
   return mat;
}

function int [] readSet(string fName) {  // bsp
   string optName = extend_name(fName);
   ifstream ipt(optName); 
   int n = ipt.getLine().toInt();
   int vec [1..n];
   forall(i in 1..n){
      string [] line = ipt.getLine().split(" ");
      vec[i] = line[0].toInt();
   }
   return vec;
}

// WRITE and STORE functions

function void printMat(int [,] mat) {
   int n = mat.getSize(0);
   forall(i in 1..n){
      forall(j in 1..n) cout << mat[i,j] << " ";
      cout << endl;
   }
}


function void storeMat(int [,] mat) {
   int m = mat.getSize(0);
   int n = mat.getSize(1);
   string fName = "mat_"+ IntToString(m) + "_" + IntToString(n) + ".txt";
   string optName = extend_name(fName);
   ofstream opt(optName); 
   opt << mat.getSize(0) << " " << mat.getSize(0) << endl;
   forall(i in mat.getRange(0)){
      forall(j in mat.getRange(1))
         opt << " " << mat[i,j];
      opt << endl;
   }
   opt.close();
}

function void showMat(int [,] mat) {
   forall(i in mat.getRange(0)){
      forall(j in mat.getRange(1))
        cout << mat[i,j] << " ";
      cout << endl;
   }
}


// Random functions

function RandomPermutation setPermutation(range rg){
   int seed = System.getCPUTime();
   //cout << seed << endl;
   RandomPermutation perm(rg);
   forall(i in 1.. seed) {perm.get(); perm.reset();}
   return perm;
}

function UniformDistribution setDistribution(range rg){
   return setDistribution_b(rg);
}

function UniformDistribution setDistribution_a(range rg){
   int seed = System.getCPUTime();
   UniformDistribution dista(rg);
   forall(i in 1.. seed) dista.get();
   UniformDistribution distb(rg);
   forall(i in 1.. dista.get()) distb.get();
   return distb;
}

function UniformDistribution setDistribution_b(range rg){
   int seeda = System.getCPUTime();
   int seedb = System.getCPUTime();
   forall(i in 1..53) seeda = System.getCPUTime();
   forall(i in 1..57) seedb = System.getCPUTime();
   int seed = seeda * seedb;
   UniformDistribution dist(rg);
   forall(i in 1.. seed) dist.get();
   return dist;
}
function UniformDistribution setDistribution_c(range rg){
   RandomPermutation pp = setPermutation(rg);
   int seed = pp.get();
   cout << "seed: " << seed << " -> ";
   UniformDistribution dist = setDistribution_a(rg);
   int test = dist.get();
   while (test != seed) {test = dist.get();}
   return dist;
}
